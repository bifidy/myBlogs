第二章 万变不离其宗——数据

###从二进制到对象

---

在本篇开篇之初，你不妨先看看这篇文章：[逼格更高-让不懂编程的人爱上iPhone开发1-Swift+iOS8版 -开篇][1]。文章是笔者无意中在[CocoaChina][2]上看到的，其中**关于计算机语言**的举例非常适合科普。
大部分的计算机原理总是散落在各个知识层面上，需要我们自己去归纳和体系化。从零散的知识当中理出一条清晰的脉络，也是学习的必备技能之一。  

#### **二进制**   
 
在计算机科学发展的历史中，从来不缺乏智慧。二进制先于电子科学被发明，却成为了电子科学的基石。就笔者自己观点而言，二进制可以看作是数学与逻辑的高度统一，虽然笔者自己也说不出什么是逻辑。另一方面，二进制使物理化、自动化的计算变的容易且高度可执行。  
废话不多，先上代码。鉴于笔者之前学过一捏捏单片机（[详见百度百科][3])，出于展示的目的，笔者用`swift`编写了一个片段，来模拟演示单片机中是如何使用纯粹的逻辑进行计算的。（如果您之前还未接触过`swift`也无妨，只需要查看运算函数如何使用逻辑运算符进行运算即可。此外，笔者也将本篇文章的展示代码以`Playground`形式放在了[Github][4]上，您可下载至本地进行调试）：  


<pre lang = "swift">
// 单片机8位二进制加法模拟=========================
//1.模拟硬件环境
let I = true
let O = false

var ACC = [O,O,O,O,O,O,O,O] //累加器ACC
var B = [O,O,O,O,O,O,O,O] //寄存器B
var AC:Bool = false //半进位标志位

//传递值至累加器
func MOVA(input: [Bool]) -> Void{
    ACC = input
}

//不借位加法
func ADD(input: [Bool]) -> Void{
    B = input
    for index in 0...7{
        ACC[index] = ACC[index] != B[index]
    }
}

//借位加法
func ADDC(input: [Bool]) -> Void{
    B = input
    for var index = 7; index >= 0; --index{
        ACC[index] = ACC[index] != AC
        AC = !ACC[index] && AC
        ACC[index] = ACC[index] != B[index]
        AC = AC || (!ACC[index] && B[index])
        //PS:这段运算逻辑为本人臆测，或许有更简单的办法
    }
    AC = false
}

/**
赠品：将二进制转化为十进制并打印
:param: input 需要填入的二进制数组
:param: name  数组的名称
*/
func LOG(input: [Bool],name: String) -> Void{
    var decimal = 0
    var weight = 1
    for var index = 7; index >= 0; --index{
        if input[index] {
            decimal += weight
        }
        weight *= 2
    }
    println("\(name) is \(decimal)")
}

//2.开始测试
let R0 = [O,O,O,O,O,I,I,O]
let R1 = [O,O,O,I,I,O,O,O]
let R2 = [O,O,O,I,I,O,O,O]
LOG(R0, "R0") //R0 is 6
LOG(R1, "R1") //R0 is 24
LOG(R2, "R2") //R0 is 24
MOVA(R0)
ADD(R1)
LOG(ACC, "ACC") //ACC is 30
ADDC(R2)
LOG(ACC, "ACC") //ACC is 54
</pre>

在上面这段代码中，展示了单片机的`MOV`、`ADD`、`ADDC`指令的具体实现。而这几个指令，其实全部来自汇编语言。  
梳理一下以前笼统的概念吧，通常的语言按层次与转化过程划分为高级语言 -> 汇编语言 -> 机器码。  
一般而言，编译器会将我们编写好的程序转化为汇编语言，这点以后再说。汇编语言到机器码的转换则相对简单，对一个8位单片机来说，每一个指令都对应着一个二进制操作码，然后与指令的参数（当然也是二进制）凑成8位的整数倍，存在一个叫做RAM的内存区域，用来按一定程序执行。对应的，所有的标志位，寄存器，和数据的储存会放在一个叫做ROM的内存区域。至此，我们就把一个程序完全转化成了二进制，储存在了内存中以待执行。（顺便一提，这种把程序和数据分开储存的架构就叫做[哈佛结构][5]）。  
随着计算机系统的复杂，真正的底层技术在上述的架构上进行了很多拓展和革新，但正如本文题目所言，万变不离其宗，数据，是这一切的原点。所有的一切，最终的物理归宿都是储存介质上的二进制数据，无一例外。  
笔者知识所限，以上代码的实现过程可能并不完全符合真实的汇编指令，只希望您能通过这个小例子理解我们所书写的代码在真实世界中到底是以怎样的形式存在。  
刚才提到过，每一个汇编指令都对应着一个二进制操作码，这里一定要说的一点是，在不同的运算芯片和计算机架构，这些对应并不完全相同，换言之，汇编语言的可移植性并不强。即便对于`iOS`开发来说，我们遇到的硬件底层数量已经大大降低，可就在本文书写的同时，我们的程序正要求从32位进化为64位，背后的原因当然是因为处理器。  
也所以，在一般的iOS开发中，我们并不用将过多的精力投入在汇编层中，即便在调试中，我们常看到程序`crash`在一大片的汇编指令中，它们提供的信息还是很有限。  
（或许是笔者经验太浅，没有接触过任何根据汇编指令进行调试的方法，如果以上表述有误，还请指出，不甚感谢。）  

#### **基础数据类型**
 
刚才在讨论二进制的时候，着眼点是放在储存上的。现在我们已经知道了，我们编写的所有代码最终都会以二进制的方式储存在某个地方的时候，我们就可以换个着眼点了。  
在C语言中，基本的数据类型也同时伴随着一个关键字，如下表所示：

|类型|关键字|
|:---:|:---:|
 整型|int
 长整型|long
 短整型|short
 单精度浮点型|float
 双精度浮点型|double
 字符型|char
 
以上6种类型之所以称为基础类型，并以此分类，大部分是科学设计和长期开发实践的结果，这里不再纠结原因。而`Objective-C`（以下简称OC）作为C语言的超集，自然也是全盘接收。在OC中，还多出了一个`BOOL`类型。
不同的数据类型，储存空间不同，编码方式也不同。
 * 整形变量会根据无符号整数(`unsigned`)的声明标志来确定是否使用[补码][6]来进行存储。
 * 浮点型则将编码分为了数据与小数点位两部分，用来记录小数。
 * 字符型则会采用标准化的字符集编码，C语言使用了`ASCII`，在OC中则可以选择字符的编码类型，例如如`utf8`。
（顺带一提，虽然BOOL型只需要一个二进制位就可以记录值，可实际上却占用了一个字节，也就是8位。想想也是挺浪费的，不过另外7位除了别的`BOOL`值也没其他类型可以用，更何况按位记录内存地址的开销又得花费额外的4位(0:0000~7:1111)，所以，别麻烦了，现代设备倒也不缺那点空间，就这样吧= =）

相对来说，数据的储存空间不同对程序的影响会更大。在C语言中，当我们声明一个变量的时候，变量其实包含了3个值。一个是它的标识符，也就是名字。一个是它的地址，而这个变量真正储存的值，是通过用标识符找到对应的地址，然后从地址当中读出来的。这里的关键点在于地址值，要知道我们的内存区域其实是个排好了序号的矩阵，每个最小单元就数据而言，还是一个字节，也就是8位二进制。比如说一个float型的数据用了4个字节来存储，那我们应该如何去记录它的地址值呢？
C语言的做法是，只记录一个变量的起始地址，然后根据变量类型去计算和取出数据。这样的设计，使所有变量的地址值都变得短小、等长、且又唯一。
这里给出一段C语言的片段来证明：

<pre lang="c">
short shortArray[2]={1,1}; //00000000 00000001 00000000 00000001
int *intpoint = shortArray;
NSLog(@"%d",*intpoint); //return 65537
</pre>

例子中，我们利用了一些C语言的特性。首先，C语言数组的地址是连续的，而两个2字节的`short`型数据同一个4字节的`int`型数据储存空间大小恰巧相同。所以我们声明了一个int型的指针指向了该数组的首地址，就会读出一个1*65536+1的数字了。

#### **结构化数据**

###常量与变量

---

再次把常量提到一个高度，已经是swift的时代了。在此之前，常量在各个语言中并不是很受重视。


###结构体、指针与对象

---



###函数、方法与block

---



###数据的传递方式

---

值传递，地址传递，引用传递。

###然后

---

《编译原理》


[1]: http://zhuanlan.zhihu.com/kidscoding/19855085
[2]: http://www.cocoachina.com
[3]: http://baike.baidu.com/view/1012.htm
[4]: https://github.com/bifidy/myBlogs
[5]: http://baike.baidu.com/view/368294.htm
[6]: http://baike.baidu.com/view/377340.htm