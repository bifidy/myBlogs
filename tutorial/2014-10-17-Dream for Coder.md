iOS学有所思系列

#第一章  iOS启程——程序员之梦
文/某鸟


作为系列第一章，本文不涉及代码级描述，仅仅是将开发时候的一些思考和总结的道理列举出来。道理相同，这些规律总是包含但不仅限于开发之中，大部分思路本身就是一种解决问题和处世的方法。  
对笔者来说，能尽可能多的运用和完善这样的方法去做的工作，才是喜欢的工作，程序员，就是个不错的选择。

##模块化
通常，我们把可以运行在iOS设备上的软件开发统称为iOS开发。这样的定义其实很笼统，在具体的开发环境中，根据选择方向的不同，所学习的技能和知识体系也是不一样的。  
无论是从具体的开发工作，还是从广义上的产品划分，体现的都是越来越多的模块化特征。所以现代更倾向于去讨论它们都包含什么，而非它们是什么。  
模块化往往意味着两件事，底层的高度集成，与模块间的频繁交互。单独模块的功能独立且完善，有高度的可替换性，模块间进行多个维度的交流，融合与包含，继而构造出一个复杂却有灵活的系统。这样的构造方式，已经在整个社会生活中由以往的被动接受而变化为现代的主动构建。  
复杂的东西往往不容易归纳，所以我们仅作列举。现实生活中可模块化的事物其实很多，利用抽象化的特征加以限制和规范，所获得的价值是无法估量的。从工业的流水线，到管理部门的职权分立，再到应用到产品研发的模块化设计与并发开发。一个接一个或大或小的革命性创造，都是模块化思维的演绎。

##角色感
与模块化相应的是角色感。模块化定义的是事物，而角色感则用来定义我们自己。
从小到大三个层面去诠释角色感。  

 * **模块角色**：构造模块的时候，需要定义模块的特征，功能，和接口等等。这种决定往往是单向且具有上帝视角的，我们希望有一个什么什么样的模块，可以以什么样的方式，来实现什么功能。而当我们进入模块，充当模块去演绎这些需求时，关注点就变为了模块本身，开始思考实现的方法，效率以及输入和输出。这样一正一反的思考方式，可以在限定模块应该有什么的同时，也明确了模块不应该有什么。  
同时，模块角色的演绎会屏蔽外部环境，或者说，模块内部不知道外面会发生什么，更不知道外面会给你一个什么样的参数。健全的模块会对参数甚至环境做限制和判断，而不是把希望寄托在文档、说明书与口首相传上。  

 * **设计角色**：如果说模块角色是让我们扮演构成系统的元素，那么设计角色则需要我们扮演系统本身。用创世者来视角比喻设计角色或许比较贴切。在这个视角下，我们的关注点主要有两个，一个是单独模块的功能，而另一个，则是模块之间的联系方式。让系统难以维护的主要原因只有一个，模块之间的联系复杂且没有规则，有一个名词叫做“熵”，就是用来统计系统的无序程度的。	
 在设计角色下，我们不用再过度的关注模块内部到底都在做什么，而应该去关注如何有序的，低耦合的组织各个模块。当然了，这里会涉及到迭代，在一个系统内，任何元素都是不完美的。在规则化的系统调整中，总会涉及到模块的重构，在这里，角色切换就起到了辅助作用。不要以设计角色的角度去重新设计模块，模块的功能从来都是模块角色与设计角色沟通的结果，这在一定程度上限制着设计角色。	
 试问，哪个人不希望自己的系统中有一个模块，只要你一个眼神，就能给你你想要的答案呢。这时候模块角色就会跳出来说一句：“别闹！”整个系统的构造从来都是一个复杂的过程，任何一步都应当建立在反复的检验和论证中，设计角色最需要保证的并不是不出错，而是整个体系的规则化与合理化。	
 
 * **用户角色**：这是一个与设计角色相辅相成却又处处作对的角色。用户角色不同于设计角色与模块角色的理性，用户角色是人性角色。而说到底，用户角色才是真正的功能设计角色，因为只有用户角色才会提出需求，再交由设计角色与模块角色去实现。  
在构造系统的过程中，用户角色往往代表着最高规则，所有的一切都为其服务。一方面，这体现着需求决定一切的构造理念，但另一方面，这也意味着我们已经做了假设——“用户永远是对的”。可在现实生活中，用户并不总是对的，甚至，有时候用户是无知的。  
用户角色并不是让我们扮演用户，而是让我们扮演系统中人性化的层面。一方面，我们关注如何将用户需求转化为系统功能，一方面，我们关注系统如何有效的将信息反馈给用户。从实践角度来说，这样的思考方式往往是异步甚至反规律的，很多情况下，用户视角需要先于用户提出用户的问题并加以解决，这也是为什么说用户视角意味着人性。  
人性是复杂的，意味着情绪，意味着爱憎，意味着对解决现实问题的工具有着高度渴望，同时对使用工具产生的怀疑、信赖、畏惧和如臂使指的依赖与情怀。

实际上，角色感是人天生的技能。假设，想象，扮演，这些能力并不需要过多的学习。如果你希望，你可以在脑海中扮演任何你希望扮演的事物。以上对角色感的划分只不过是对构建模块化系统的又一次实践演习而已，限制了每个角色的主要工作，同时规定了他们的交互方式，希望在构造完成后，身为用户的你使用起来不会太吃力。  
我用我构造的系统进行思考构造了一个系统，这算不算是一次递归呢？噗，笔者自己开个小玩笑。

##Bug
完美是极限，是理想，是没有一张没沾上一丁点污渍的白纸。  
不过在现实中，能成就完美的事物少之又少。学会接受不完美，是一种生活的态度。  
没有细细探究过Bug这个词究竟是起源于何处，也没有认真的限定过什么才算是Bug。
对于初学者来说，Bug可能只是漏写了语句的结尾符号，是把`==`写成了`=`。  
对于开发者来说，Bug可能是动态特性导致的程序崩溃，可能是并发操作中的资源异常。
对于测试者来说，Bug也是功能实现和预期不一致，甚至会问你按钮怎么是灰色，然后你告诉他，哦，你得先在这个选项上打勾。  
就一般情况而言，Bug往往是描述一种状态，出错的状态。这种状态不符合预期，且已经出现在了本不该出现的场合。  
但是一个Bug为什么会出现，往往不是一两句话能说的清楚。我只记得遇见Bug时那几句经典而不变的口头禅“我看看！”“怎么可能！”“哦，我忘记说了。。。”  
既然说了这篇文章不会提及具体代码，所以写这一段我自然也不是为了总结如何做个Debugger。 
 
我想说的是，我们应该如何去面对Bug。  
在软件开发工具里，有两类工具是长盛不衰的，一类工具帮助我们尽可能高效的编写代码，一类工具则帮助我们尽可能高效的找到代码中的Bug。在任何一个优秀的IDE里，这两个特性都是最为开发者们所关注的。
虽然这样描述让人不寒而栗，但事实是，Bug确实像蟑螂一样，在开发的长河里，生命顽强，相伴相生。这是开发的宿命，一朝遁入编程海，从此完美是路人。  
开发者也是人，是人，就会犯错误。

 * 第一类错误显得浅显易懂，错误的成因或许是一声哈欠，一次误点，一次手贱，写错了单词，忘记了句子。我们知道怎样做是正确的，但我们却做错了。有一个比较官方的称呼将这类错误称为“低级错误”，它们最不应该发生。传说有一枚火箭发射失败是因为把`==`写成了`=`，传说苹果之前有一个验证漏洞是因为多写了一句`goto`。
无论传言真实与否，这类Bug的错误，所带来的懊悔之情，也往往是诸多Bug之中最浓重的。如果你对这类Bug的频繁出现感到麻木的时候，那建议你辞职换个职业，比如神父。听着信徒说对不起我今天犯了什么样的错，我本来不该这么做的。然后你充满信仰的劝诫：“安心吧，神会宽恕我们的。”

 * 第二类错误往往来源于无知。说真的，又有多少人是全知全能的呢，真正的开发路上，数不尽的人在边学边试边写，有时候甚至觉得一个只写他一定会的东西的人，多多少少有点坐吃山空。外部环境从来没有我们想象的那么理想，也非我们所看到的那般透明。笔者也是从并发编程中在真正意义上理解了什么叫做有概率出现Bug，父母问我家里的网怎么上不去了，我第一件事总是让他们看看电源。  
这类Bug的出现是无可厚非的，它们应该出现，它们对应着我们的无知与弱点。它们出现的越早，意味着我们会越早的解决，直到将无知慢慢的消化为已知，直到我们再看到同一个Bug的时候，觉得这只是个第一类Bug而已。  

 * 第三类错误与第二类错误同源，却来自更深的一个维度。任何我们认为是正确，且经过验证确定正确的东西，在未来的某个时间中，或者在进入某个新的环境中，会变成错误。这样的错误往往比第二类错误来得更匪夷所思，且难以置信。
因为无知引发的错误，在面对时，我们至少是心悦诚服的。但对已知的质疑就来得猝不及防，继而恐惧，因为我们不知道自己的已知中究竟还潜藏着多少这样的潜在错误。面对这样的错误，我们能做的只是更为强大的理性。从建立知识体系之初就确信所有的知识都是不完善的，是需要更新的，所有的确切与正确都是有条件限制的，把他们转化为第二类错误吧，即便有的时候这种转化往往伴随着阵痛。牛顿经典力学被爱因斯坦推翻的时候怎么办？柯达倒闭的时候怎么办？貌似，除了接受与改变，也没什么别的办法了。

 * 第四类错误或许无法被称之为错误。韩寒的《后会无期》中说“年轻人才分对错，大人只看利弊”，对错之间，往往夹杂着一个判定标准。在这个标准本身就充满质疑的时候，又或者不足以决定结果的时候，正确与错误，也就演化成为了妥协与执着。  
苹果的标志上有一个缺口，是完美还是不完美呢。如果人工智能有一天超越人类，那还应不应该继续研究呢？对错并不总是有意义，所以在对待对错的时候，我们的第一个态度永远应该是宽容，不是么。

时间是不可逆的，我们在修正和避免Bug的同时，新的Bug总是会找上门来的，对已知的Bug尽可能的严苛，对未知的Bug也不心存畏惧。它们是我们进步的脚印和阶梯，唯一要记住的是，尽早解决……

##数学与逻辑
人类的智慧是伟大的，数学和逻辑在某篇文章上被说成是最牛逼的语言，从笔者观点来看，更倾向与说成是最牛逼的工具。毕竟语言作为工具，最主要的职能是表达。虽然原文中的语言指的是编程语言，不过只拿数学和逻辑还是有些屈才的。
在人类的进化史上，数学与逻辑解决的问题不计其数，笔者就不一并讴歌了。  
回到程序员的起点上，数学与逻辑，是隐性的必修课。  
如果说拿出一门编程语言，最好是你正在使用的，问你这门语言的特性，想必你首先背段课文，然后说说自己的实践体会，会其他语言的话还能列举出诸多不同，洋洋洒洒的说个好久。  
可数学与逻辑到底是什么呢？  
嗯，我也说不上来。  
似乎大家的认知都差不多，逻辑意味着`if`,意味着并、或、非。而数学，则意味着算法，意味着循环。  
感觉只有在以上情况下，我们才会意识到，我们在使用逻辑和数学。  
希望从业年龄更久远，工具应用更成熟的前辈们能给出更有深度的解答，但对我而言，这已经是我的高度了，即便我对这个答案一点也不甘心。  
好好学习，没什么可解释的。  
数学与逻辑，从来都是理性中最有力的武器，没有它们，面对问题只是等死的前戏而已，因为无法解决。




