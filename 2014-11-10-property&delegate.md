第四章 类内实例——从Property到Delegate

文/某鸟

从本章内容开始，会逐渐具化的展示在OC当中常见的一些概念和


###属性标记

在[第三章 语法浅析——从C语言到Objecitve-C][1]中，笔者已经展示了编译器在遇到`@property`之后，替我们添加的一系列代码。不过在常见的代码示例里，我们遇到的属性声明往往是这个样子的：

<pre>
@property (nonatomic,weak) IBOutlet UIView *view;
</pre>

主要的功能拓展都在圆括号中以参数的方式提交给编译器，让编译器在生成属性的时候，添置额外代码。常见的参数可以分为四类。

 * **多线程保护**  即`nonatomic`与`atomic`，简单来说，就是当属性为`atomic`时，代码中会附加对该属性的线程保护，如此做会保证该属性的线程安全，但也会消耗额外的储存资源。默认情况下，当你不附加参数时，属性是以`atomic`方式生成的，当属性不涉及线程操作时，我们应该为属性声明`nonatomic`。

 * **可读可写**  即`readonly`与`readwrite`。在`readonly`声明下，编译器将只生成该属性的`getter`，以确保我们无法调用`setter`来修改该属性的值。而`readwrite`则意味着`setter`与`getter`都被生成，默认情况下，属性的该参数为`readwrite`。

 * **内存管理**  常见的参数是`strong`与`weak`，除此之外还有`copy`与不常见到的`unsafe_unretained`等等，这类参数直接对应着指针的内存管理，我们在下文中会详细介绍。默认情况下,属性的该参数为`strong`。

 * **存取方法**  这个参数可以修改属性的`getter`与`setter`方法名，写法类似于`getter = anotherName`。这个参数的使用中，比较常见的是`UIView`的`hidden`属性，它的`getter`是`isHidden`。需要注意的是，`readonly`声明下，是不会生成`setter`的，这时候即使你声明了`setter = setValue`，该`setter`也不会被生成。

常见的文献讨论中，大部分会过于倚重对于名词的讲解，而忽略了以上的分类。其实在日常的开发中，线程保护、可读写、与内存管理标记，都是非彼即此的。像以下的两句声明，其实是等价的：

<pre>
@property (atomic,strong,readwrite) NSObject *obj;
@property NSObject *obj;
</pre>

关于属性的声明，更为详细的方法与解释可以参考这篇[官方文档][2]，在此不再赘述。

###点语法

提到了`getter`与`setter`，我们就顺便说一说点语法了。

###内存管理

在[第二章 底层浅析——从二进制到对象][3]中，笔者曾简单的交待过OC中的内存管理机制——引用计数机制（Reference Counting）。这个机制的关键在于控制OC在初识化对象的时候就为我们生成的一个属性：`retainCount`。在以前的MRC时代，这个属性是可读的，你可以随时用该值来判断某个对象的内存状态。不过在ARC中，我们已经大大简化了管理方式，基本上，我们只需要面对或`strong`或`weak`的属性。或许在个别情况下还是会用到其他声明，笔者实力有限，就不细加列举了。

在ARC中，关于`strong`与`weak`，需要明确的规则只有两条。

 * 被`strong`指针指向的对象一定是存在的，当且仅当一个对象没有被任何`strong`型的指针指向时，它才会被释放。
 * 当你不确定指针指向的对象是否一直存在，或者你并不希望该对象一直存在时，就为这个指针声明`weak`。

第二条规则算是有的放矢，前半句为了防止访问不存在的变量，后半句则是防止循环引用（retain cycle）。
在OC中有一个很有用的机制，是一个weak属性并没有指向某个具体的对象时，系统会让该指针指向`nil`，而`nil`可以响应一切方法，响应的结果是什么事情也不会发生，没有报错，没有`crash`，当然因为是nil，方法里的一切代码也不会被执行。

简单解释一下循环引用，就是两个对象互相拥有一个指向对方的强指针，导致彼此都无法被释放，关于为什么可以参见上面的第一条规则。但在理论上，一切对象在最终都应该被释放，那么如何既让两个对象可以相互指向并进行调用，又能够互不影响的释放呢？对对对= =，当然是`weak`。

顺便说一说MRC，在MRC时代，内存管理机制更多依靠的是约定俗成。

 * 谁生成/持有，谁释放。真正意义上的`retainCount`修改操作方法只有两个，`retain`与`release`，一个+1，一个-1。通常在文献中还会把`autorelease`也与其并列，而其实，`autorelease`只是release的延时封装，用于处理某些不希望被立即释放的对象。这里的“谁”有两层意思，一层意思是进行生成/持有操作的指针应该与释放操作的指针相对应，否则的话，说不定会出现以下的代码：

<pre>
for(int i = 0 ; i < obj.retainCount ; i++){
	[obj release];
}//千万别这么写= =
</pre>

 而另一层意思相对隐晦些，是在说一个指针的释放时机与该指针的声明周期要相符合，也就是作用域。比如方法内的临时指针要在方法内释放，类内实例的释放则在析构函数`dealloc`里。每一次`retainCount`的+1都意味着一个指针会至少经历**出现**，**存在**，**释放**三个阶段，而每一句`release`都同时决定着**存在时长**与**不再存在**两件事，还请稍稍多体会些。

* 所有以alloc,copy,retain开头的方法都封装了`retain`操作，需要手动释放。而其他成对的生成/持有与释放成对存在的方法也可能存在类似性质，如`addSubview`与`removeFromSuperview`，务必成对引用。这类约定俗成往往需要编码者来完成，不要随意以以上开头写方法，不要在额外的方法里[self retain];，需成对使用的方法请在注释和文档里注明。

在MRC下面管理内存是一件比较繁琐与精细的事情，稍微一个马虎就可能引发程序奔溃或者内存不足。ARC的引入一定程度上也是在降低开发者的门槛，具体的使用就不再赘述了。

###类内实例

没有之前在底层实现上的铺垫，讲到这里往往需要花费很多时间。如果你之前接触过数据结构，会知道数据结构其实是包含着**逻辑结构**与**物理结构**（储存结构），逻辑结构与物理结构并不一定要统一。C语言的数组是为数不多逻辑结构与储存结构相同的数据结构之一，但是在实践中，让逻辑结构与物理结构统一并不是一件好事。比如一个C语言的数组中间所有值为0的位置即便再也用不到，只要数组还在，你就无法使用那些内存。

与这样的思路一脉相承，我们在构造类内实例的时候，其实只是构造了它们的逻辑结构，而在实际上，任何两个对象是不存在谁属于谁的。在物理存储上，他们的等级是完全平行的。唯一用以标记这种逻辑关系的，只不过是一个类内的指针而已。真正在物理上具有所属关系的，反倒是一个对象和这个对象内的指针。

与此相区别的是面向对象的继承机制，相对于类内实例的模拟来说。父类与子类的逻辑关系就严谨的多，从数据结构来说，它们类似于单向链表，即所有的子类都记录了自己的父类，但父类则不会记录自己的子类，而所有的继承遍历都严格按照这个结构自底向上。好吧，我们扯远了= =

对象间的关系都是两点一线的，两个独立的实例，一个从一点指向另一点的指针。因为是指向，所以具有方向性，被指向的指针永远不知道是谁指向自己，即便我们用两个指针相互指向，但站在对象的视角上，这一来一去，已然是两个不同的角色了。

最后补充一点可能模糊的地方，指针的指向，是为了调用，而调用，则是为了读写（或者存取？其实一个意思）。在类的内部，我们即可以使用实例的指针，也可以使用这个类的`setter`与`getter`来调用这个实例，比如一个`UIViewController`的`_view`和`self.view`是相同的效果，当然前提是你没有重写`_view`的`getter`。

而在类的外部，我们只能使用`setter`和`getter`来调用属性。除此之外，我们也可以使用`->`来调用`@public`声明的实例，不过，已经很少有人这么做了。


[1]: http://bifidy.net/index.php/307
[2]: https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html
[3]: http://bifidy.net/index.php/272